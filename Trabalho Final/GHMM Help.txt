Help on module ghmm:

NAME
    ghmm - @mainpage GHMM - an open source library for Hidden Markov Models (HMM)

FILE
    /usr/local/lib/python2.7/dist-packages/ghmm.py

DESCRIPTION
    HMMs are stochastic models which encode a probability density over
    sequences of symbols. These symbols can be discrete letters (A,C,G and
    T for DNA; 1,2,3,4,5,6 for dice), real numbers (weather measurement
    over time: temperature) or vectors of either or the combination
    thereof (weather again: temperature, pressure, percipitation).
    
    @note
    We will always talk about emissions, emission sequence and so
    forth when we refer to the sequence of symbols. Another name
    for the same object is observation resp. observation sequence.
    
    A simple model with a fair and one unfair coin can be created as follows
    
    >> fair = [0.5, 0.5]
    >> loaded = [0.9, 0.1]
    >> A = [[0.9, 0.1], [0.3, 0.7]]
    >> pi = [0.9, 0.1]
    >> B = [fair, loaded]
    >> sigma = ghmm.IntegerRange(0,2)
    >> m = ghmm.HMMFromMatrices(sigma, ghmm.DiscreteDistribution(sigma), A, B, pi)
    
    The objects one has to deal with in HMM modelling are the following
    
    -# The domain the emissions come from: the EmissionDomain. Domain
       is to be understood mathematically and to encompass both discrete,
       finite alphabets and fields such as the real numbers or intervals
       of the reals.
    
       For technical reasons there can be two representations of an
       emission symbol: an external and an internal. The external
       representation is the view of the application using ghmm.py. The
       internal one is what is used in both ghmm.py and the ghmm
       C-library. Representations can coincide, but this is not
       guaranteed. Discrete alphabets of size k are represented as
       [0,1,2,...,k-1] internally.  It is the domain objects job to
       provide a mapping between representations in both directions.
       @note
       Do not make assumptions about the internal
       representations. It might change.
    
    -# Every domain has to afford a distribution, which is usually
       parameterized. A distribution associated with a domain
       should allow us to compute $Prob[x| distribution parameters]$
       efficiently.
    
       The distribution defines the type of distribution which
       we will use to model emissions in <b>every state</b> of the HMM.
       The type of distribution will be identical for all states,
       their parameterizations will differ from state to state.
    
    -# We will consider a Sequence of emissions from the same emission
       domain and very often sets of such sequences: SequenceSet
    
    -# The HMM: The HMM consists of two major components: A Markov chain
       over states (implemented as a weighted directed graph with
       adjacency and inverse-adjacency lists) and the emission
       distributions per-state. For reasons of efficiency the HMM itself
       is *static*, as far as the topology of the underlying Markov chain
       (and obviously the EmissionDomain) are concerned. You cannot add or
       delete transitions in an HMM.
    
       Transition probabilities and the parameters of the per-state
       emission distributions can be easily modified. Particularly,
       Baum-Welch reestimation is supported.  While a transition cannot be
       deleted from the graph, you can set the transition probability to
       zero, which has the same effect from the theoretical point of
       view. However, the corresponding edge in the graph is still
       traversed in the computation.
    
       States in HMMs are referred to by their integer index. State sequences
       are simply list of integers.
    
       If you want to store application specific data for each state you
       have to do it yourself.
    
       Subclasses of HMM implement specific types of HMM. The type depends
       on the EmissionDomain, the Distribution used, the specific
       extensions to the 'standard' HMMs and so forth

CLASSES
    __builtin__.object
        BackgroundDistribution
        ComplexEmissionSequence
        Distribution
            ContinuousDistribution
                ContinuousMixtureDistribution
                GaussianDistribution
                    TruncGaussianDistribution
                GaussianMixtureDistribution
                MultivariateGaussianDistribution
                UniformDistribution
            DiscreteDistribution
                DiscretePairDistribution
        EmissionDomain
            Alphabet
                LabelDomain
            Float
        EmissionSequence
        HMM
            DiscreteEmissionHMM
                StateLabelHMM
            GaussianEmissionHMM
                GaussianMixtureHMM
                    ContinuousMixtureHMM
                MultivariateGaussianMixtureHMM
            PairHMM
        HMMFactory
            HMMFromMatricesFactory
            HMMOpenFactory
                PairHMMOpenFactory
        SequenceSet
            SequenceSetSubset
    exceptions.Exception(exceptions.BaseException)
        GHMMError
            GHMMOutOfDomain
            InvalidModelParameters
            NoValidCDataType
            ParseFileError
            SequenceCannotBeBuild
            UnknownInputType
            UnsupportedFeature
            WrongFileType
            badCPointer
    BaysianHMM
    Hyperparameters
    
    class Alphabet(EmissionDomain)
     |  Discrete, finite alphabet
     |  
     |  Method resolution order:
     |      Alphabet
     |      EmissionDomain
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, alph)
     |  
     |  __hash__(self)
     |  
     |  __init__(self, listOfCharacters)
     |      Creates an alphabet out of a listOfCharacters
     |      @param listOfCharacters a list of strings (single characters most of
     |      the time), ints, or other objects that can be used as dictionary keys
     |      for a mapping of the external sequences to the internal representation
     |      or can alternatively be a SWIG pointer to a
     |      C alphabet_s struct
     |      
     |      @note
     |      Alphabets should be considered as imutable. That means the
     |      listOfCharacters and the mapping should never be touched after
     |      construction.
     |  
     |  __len__(self)
     |  
     |  __str__(self)
     |  
     |  external(self, internal)
     |      Given an internal representation return the external representation
     |      
     |      @note the internal code -1 always represents a gap character '-'
     |      
     |      Raises KeyError
     |  
     |  externalSequence(self, internalSequence)
     |      Given a sequence with the internal representation return the external
     |      representation
     |      
     |      Raises KeyError
     |  
     |  getExternalCharacterLength(self)
     |      If all external characters are of the same length the length is
     |      returned. Otherwise None.
     |      @return length of the external characters or None
     |  
     |  internal(self, emission)
     |      Given a emission return the internal representation
     |  
     |  internalSequence(self, emissionSequence)
     |      Given a emission_sequence return the internal representation
     |      
     |      Raises KeyError
     |  
     |  isAdmissable(self, emission)
     |      Check whether emission is admissable (contained in) the domain
     |  
     |  size(self)
     |      @deprecated use len() instead
     |  
     |  toCstruct(self)
     |  
     |  verboseStr(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmissionDomain:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class BackgroundDistribution(__builtin__.object)
     |  Background distributions object
     |  
     |  holds discrete distributions used as background while training
     |  discrete HMMs to avoid overfitting.
     |  Input is a discrete EmissionDomain and a list of list. Each list is
     |  a distinct distribution. The distributions can be of higher order.
     |  The length of a single distribution is a power of len(EmissionDomain)
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |  
     |  __init__(self, emissionDomain, bgInput)
     |  
     |  __str__(self)
     |  
     |  getCopy(self)
     |  
     |  getName(self, i)
     |      return the name of the ith backgound distrubution
     |  
     |  setName(self, i, name)
     |      sets the name of the ith background distrubution to name
     |  
     |  toLists(self)
     |  
     |  updateName2id(self)
     |      adds all background names to the dictionary name2id
     |  
     |  verboseStr(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class BaysianHMM
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomain, distribution, dim, n, m, priorInitial, priorTransitions, hyperparameters)
     |  
     |  sample(self)
    
    class ComplexEmissionSequence(__builtin__.object)
     |  A MultivariateEmissionSequence is a sequence of multiple emissions per
     |  time-point. Emissions can be from distinct EmissionDomains. In particular,
     |  integer and floating point emissions are allowed. Access to emissions is
     |  given by the index, seperately for discrete and continuous EmissionDomains.
     |  
     |  Example: XXX
     |  
     |  MultivariateEmissionSequence also links to the underlying C-structure.
     |  
     |  Note: ComplexEmissionSequence has to be considered imutable for the moment.
     |  There are no means to manipulate the sequence positions yet.
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |      Deallocation of C sequence struct.
     |  
     |  __getitem__(self, key)
     |      get a slice of the complex emission sequence
     |      @param key either int (makes no big sense) or slice object
     |      @return a new ComplexEmissionSequence containing a slice of the
     |      original
     |  
     |  __init__(self, emissionDomains, sequenceInputs, labelDomain=None, labelInput=None)
     |      @param emissionDomains a list of EmissionDomain objects corresponding
     |      to the list of sequenceInputs
     |      @param sequenceInputs a list of sequences of the same length (e.g.
     |      nucleotides and double values) that will be encoded
     |      by the corresponding EmissionDomain
     |      @bug @param labelDomain unused
     |      @bug @param labelInput unused
     |  
     |  __len__(self)
     |      @return the length of the sequence.
     |  
     |  __str__(self)
     |      string representation. Access the underlying C-structure and return
     |      the sequence in all it's encodings (can be quite long)
     |      @return string representation
     |  
     |  getDiscreteSequence(self, index)
     |      get the 'index'th discrete sequence as it has been given at the input
     |      @param index number of the discrete sequence
     |      @return a python sequence
     |  
     |  getInternalContinuousSequence(self, index)
     |      access the underlying C structure and return the internal
     |      representation of the continuous sequence number 'index'
     |      @param index number of the continuous sequence
     |      @return a python list of floats
     |  
     |  getInternalDiscreteSequence(self, index)
     |      access the underlying C structure and return the internal
     |      representation of the discrete sequence number 'index'
     |      @param index number of the discrete sequence
     |      @return a python list of ints
     |  
     |  verboseStr(self)
     |      string representation. Access the underlying C-structure and return
     |      the sequence in all it's encodings (can be quite long)
     |      @return string representation
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ContinuousDistribution(Distribution)
     |  Method resolution order:
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ContinuousMixtureDistribution(ContinuousDistribution)
     |  Method resolution order:
     |      ContinuousMixtureDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |  
     |  add(self, w, fix, distribution)
     |  
     |  check(self)
     |  
     |  get(self, i)
     |  
     |  set(self, index, w, fix, distribution)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ContinuousMixtureHMM(GaussianMixtureHMM)
     |  HMMs with mixtures of any univariate (one dimensional) Continuous
     |  Distributions as emissions.
     |  
     |  Optional features:
     |  - fixing mixture components in training
     |  
     |  Method resolution order:
     |      ContinuousMixtureHMM
     |      GaussianMixtureHMM
     |      GaussianEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |      defines string representation
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |      It also returns the density type
     |  
     |  getEmission(self, i, comp)
     |      @returns the paramenters of component 'comp' in state 'i'
     |      - (type, mu,  sigma^2, weight)        - for a gaussian component
     |      - (type, mu,  sigma^2, min,   weight) - for a right tail gaussian
     |      - (type, mu,  sigma^2, max,   weight) - for a left  tail gaussian
     |      - (type, max, mix,     weight)        - for a uniform
     |  
     |  setEmission(self, i, comp, distType, values)
     |      Set the emission distribution parameters for a mixture component
     |      of a single state.
     |      
     |      @param i index of a state
     |      @param comp index of a mixture component
     |      @param distType type of the distribution
     |      @param values tuple (mu, sigma, a , weight) and is interpreted depending
     |      on distType
     |      - mu     - mean for normal, normal_approx, normal_right, normal_left
     |      - mu     - max for uniform
     |      - sigma  - standard deviation for normal, normal_approx, normal_right,
     |        normal_left
     |      - sigma  - min for uniform
     |      - a      - cut-off normal_right and normal_left
     |      - weight - always component weight
     |  
     |  verboseStr(self)
     |      Human readable model description
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from GaussianMixtureHMM:
     |  
     |  getMixtureFix(self, state)
     |  
     |  setMixtureFix(self, state, flags)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from GaussianEmissionHMM:
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      Result: the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimate the model parameters given the training_sequences.
     |      
     |      Perform at most nr_steps until the improvement in likelihood
     |      is below likelihood_cutoff
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |      
     |      Result: Final loglikelihood
     |  
     |  baumWelchDelete(self)
     |      Delete the necessary temporary variables for Baum-Welch-reestimation
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps, loglikelihoodCutoff=0.0001)
     |      Setup necessary temporary variables for Baum-Welch-reestimation.
     |      
     |      Use with baumWelchStep for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |      Compute one iteration of Baum Welch estimation.
     |      
     |      Use with baumWelchSetup for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |  
     |  cfbGibbs(self, trainingSequences, bayes, width, delta, max_len, burnIn=100, seed=0)
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  forward(self, emissionSequence)
     |      Result: the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmissionProbability(self, value, i)
     |      @returns probability of emitting value in state i
     |  
     |  getTransition(self, i, j)
     |      @returns the probability of the transition from state i to state j.
     |      Raises IndexError if the transition is not allowed
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emissionSequences using the forward algorithm.
     |      
     |      @param emissionSequences SequenceSet
     |      
     |      Result: log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij
     |  
     |  viterbi(self, emissionSequences)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      
     |      Result: [q_0, ..., q_T] the viterbi-path of emission_sequences is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DiscreteDistribution(Distribution)
     |  A DiscreteDistribution over an Alphabet: The discrete distribution
     |  is parameterized by the vectors of probabilities.
     |  
     |  Method resolution order:
     |      DiscreteDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, alphabet)
     |  
     |  get(self)
     |  
     |  set(self, prob_vector)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DiscreteEmissionHMM(HMM)
     |  HMMs with discrete emissions.
     |  
     |  Optional features:
     |  - silent states
     |  - higher order states
     |  - parameter tying in training
     |  - background probabilities in training
     |  
     |  Method resolution order:
     |      DiscreteEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  __str__(self)
     |  
     |  applyBackgrounds(self, backgroundWeight)
     |      Apply the background distribution to the emission probabilities of states
     |      which have been assigned one (usually in the editor and coded in the XML).
     |      
     |      applyBackground computes a convex combination of the emission probability
     |      and the background
     |      
     |      @param backgroundWeight (within [0,1]) controls the background's
     |      contribution for each state.
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |  
     |  backwardTermination(self, emissionSequence, pybeta, scalingVector)
     |      Result: the backward log probability of emissionSequence
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimates the model with the sequence in 'trainingSequences'.
     |      
     |      @note that training for models including silent states is not yet
     |      supported.
     |      
     |      @param trainingSequences EmissionSequence or SequenceSet object
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  cfbGibbs(self, trainingSequences, bayes, R=-1, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence or SequenceSet
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param R length of uniform compression >0, works best for .5log(sqrt(T)) where T is length of seq
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  extendDurations(self, durationlist)
     |      extend states with durations larger than one.
     |      
     |      @note this done by explicit state copying in C
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  getBackgroundAssignments(self)
     |      Get the background assignments of all states
     |      
     |      '-1' -> no background
     |  
     |  getEmission(self, i)
     |  
     |  getSilentFlag(self, state)
     |  
     |  getTieGroups(self)
     |      Gets tied emission group structure.
     |  
     |  isSilent(self, state)
     |      @returns True if 'state' is silent, False otherwise
     |  
     |  removeTieGroups(self)
     |      Removes all tied emission information.
     |  
     |  setBackgroundAssignments(self, stateBackground)
     |      Change all the assignments of background distributions to states.
     |      
     |      Input is a list of background ids or '-1' for no background, or list of background names
     |  
     |  setBackgrounds(self, backgroundObject, stateBackground)
     |      Configure model to use the background distributions in 'backgroundObject'.
     |      
     |      @param backgroundObject BackgroundDistribution
     |      @param 'stateBackground' a list of indixes (one for each state) refering
     |      to distributions in 'backgroundObject'.
     |      
     |      @note values in backgroundObject are deep copied into the model
     |  
     |  setEmission(self, i, distributionParameters)
     |      Set the emission distribution parameters for a discrete model.
     |  
     |  setTieGroups(self, tieList)
     |      Sets the tied emission groups
     |      
     |      @param tieList contains for every state either '-1' or the index
     |      of the tied emission group leader.
     |      
     |      @note The tied emission group leader is tied to itself
     |  
     |  updateTiedEmissions(self)
     |      Averages emission probabilities of tied states.
     |  
     |  verboseStr(self)
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      @returns the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelchDelete(self)
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps)
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  forward(self, emissionSequence)
     |      @returns the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  getTransition(self, i, j)
     |      Accessor function for the transition a_ij
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emission_sequences using the forward algorithm
     |      
     |      @param emissionSequences is of type SequenceSet
     |      
     |      @returns log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij.
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  viterbi(self, eseqs)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param eseqs can either be a SequenceSet or an EmissionSequence
     |      
     |      @returns [q_0, ..., q_T] the viterbi-path of \p eseqs is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class DiscretePairDistribution(DiscreteDistribution)
     |  A DiscreteDistribution over TWO Alphabets: The discrete distribution
     |  is parameterized by the vector of probabilities.
     |  To get the index of the vector that corresponds to a pair of characters
     |  use the getPairIndex method.
     |  
     |  Method resolution order:
     |      DiscretePairDistribution
     |      DiscreteDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, alphabetX, alphabetY, offsetX, offsetY)
     |      construct a new DiscretePairDistribution
     |      @param alphabetX Alphabet object for sequence X
     |      @param alphabetY Alphabet object for sequence Y
     |      @param offsetX number of characters the alphabet of sequence X
     |      consumes at a time
     |      @param offsetY number of characters the alphabet of sequence Y
     |      consumes at a time
     |  
     |  getCounts(self, sequenceX, sequenceY)
     |      extract the pair counts for aligned sequences sequenceX and sequenceY
     |      @param sequenceX string for sequence X
     |      @param sequenceY strinf for sequence Y
     |      @return a list of counts
     |  
     |  getEmptyProbabilityVector(self)
     |      get an empty probability vector for this distribution (filled with 0.0)
     |      @return list of floats
     |  
     |  getPairIndex(self, charX, charY)
     |      get the index of a pair of two characters in the probability vector
     |      (if you use the int representation both values must be ints)
     |      @param charX character chain or int representation
     |      @param charY character chain or int representation
     |      @return the index of the pair in the probability vector
     |  
     |  setPairProbability(self, charX, charY, probability)
     |      set the probability of the [air charX and charY to probability
     |      @param charX character chain or int representation
     |      @param charY character chain or int representation
     |      @param probability probability (0<=float<=1)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from DiscreteDistribution:
     |  
     |  get(self)
     |  
     |  set(self, prob_vector)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Distribution(__builtin__.object)
     |  Abstract base class for distribution over EmissionDomains
     |  
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmissionDomain(__builtin__.object)
     |  Abstract base class for emissions produced by an HMM.
     |  
     |  There can be two representations for emissions:
     |  -# An internal, used in ghmm.py and the ghmm C-library
     |  -# An external, used in your particular application
     |  
     |  Example:
     |  
     |  The underlying library represents symbols from a finite,
     |  discrete domain as integers (see Alphabet).
     |  
     |  EmissionDomain is the identity mapping
     |  
     |  Methods defined here:
     |  
     |  external(self, internal)
     |      Given an internal representation return the external representation
     |  
     |  externalSequence(self, internalSequence)
     |      Given a sequence with the internal representation return the external
     |      representation
     |  
     |  internal(self, emission)
     |      Given a emission return the internal representation
     |  
     |  internalSequence(self, emissionSequence)
     |      Given a emissionSequence return the internal representation
     |  
     |  isAdmissable(self, emission)
     |      Check whether \p emission is admissable (contained in) the domain
     |      raises GHMMOutOfDomain else
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class EmissionSequence(__builtin__.object)
     |  An EmissionSequence contains the *internal* representation of
     |  a sequence of emissions.
     |  
     |  It also contains a reference to the domain where the emissions orginated from.
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |      Deallocation of C sequence struct.
     |  
     |  __getitem__(self, index)
     |      @returns the symbol at position 'index'.
     |  
     |  __init__(self, emissionDomain, sequenceInput, labelDomain=None, labelInput=None, ParentSequenceSet=None)
     |  
     |  __len__(self)
     |      Returns the length of the sequence.
     |  
     |  __setitem__(self, index, value)
     |  
     |  __str__(self)
     |      Defines string representation.
     |  
     |  asSequenceSet(self)
     |      @returns this EmissionSequence as a one element SequenceSet
     |  
     |  getGeneratingStates(self)
     |      @returns the state path from which the sequence was generated as
     |      a Python list.
     |  
     |  getSeqLabel(self)
     |  
     |  getStateLabel(self)
     |      @returns the labeling of the sequence in external representation
     |  
     |  getWeight(self)
     |  
     |  hasStateLabels(self)
     |      @returns whether the sequence is labeled or not
     |  
     |  sequenceSet(self)
     |      @return a one-element SequenceSet with this sequence.
     |  
     |  setSeqLabel(self, value)
     |  
     |  setWeight(self, value)
     |  
     |  verboseStr(self)
     |      Defines string representation.
     |  
     |  write(self, fileName)
     |      Writes the EmissionSequence into file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Float(EmissionDomain)
     |  Continuous Alphabet
     |  
     |  Method resolution order:
     |      Float
     |      EmissionDomain
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |  
     |  __hash__(self)
     |  
     |  __init__(self)
     |  
     |  isAdmissable(self, emission)
     |      Check whether emission is admissable (contained in) the domain
     |      
     |      raises GHMMOutOfDomain else
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from EmissionDomain:
     |  
     |  external(self, internal)
     |      Given an internal representation return the external representation
     |  
     |  externalSequence(self, internalSequence)
     |      Given a sequence with the internal representation return the external
     |      representation
     |  
     |  internal(self, emission)
     |      Given a emission return the internal representation
     |  
     |  internalSequence(self, emissionSequence)
     |      Given a emissionSequence return the internal representation
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmissionDomain:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class GHMMError(exceptions.Exception)
     |  Base class for exceptions in this module.
     |  
     |  Method resolution order:
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class GHMMOutOfDomain(GHMMError)
     |  Method resolution order:
     |      GHMMOutOfDomain
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class GaussianDistribution(ContinuousDistribution)
     |  Method resolution order:
     |      GaussianDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |      # XXX attributes unused at this point
     |  
     |  get(self)
     |  
     |  set(self, values)
     |      @param values tuple of mu, sigma, trunc
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class GaussianEmissionHMM(HMM)
     |  HMMs with Gaussian distribution as emissions.
     |  
     |  Method resolution order:
     |      GaussianEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  __str__(self)
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      Result: the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimate the model parameters given the training_sequences.
     |      
     |      Perform at most nr_steps until the improvement in likelihood
     |      is below likelihood_cutoff
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |      
     |      Result: Final loglikelihood
     |  
     |  baumWelchDelete(self)
     |      Delete the necessary temporary variables for Baum-Welch-reestimation
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps, loglikelihoodCutoff=0.0001)
     |      Setup necessary temporary variables for Baum-Welch-reestimation.
     |      
     |      Use with baumWelchStep for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |      Compute one iteration of Baum Welch estimation.
     |      
     |      Use with baumWelchSetup for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |  
     |  cfbGibbs(self, trainingSequences, bayes, width, delta, max_len, burnIn=100, seed=0)
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  forward(self, emissionSequence)
     |      Result: the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmission(self, i)
     |      @returns (mu, sigma^2)
     |  
     |  getEmissionProbability(self, value, i)
     |      @returns probability of emitting value in state i
     |  
     |  getTransition(self, i, j)
     |      @returns the probability of the transition from state i to state j.
     |      Raises IndexError if the transition is not allowed
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emissionSequences using the forward algorithm.
     |      
     |      @param emissionSequences SequenceSet
     |      
     |      Result: log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  setEmission(self, i, values)
     |      Set the emission distributionParameters for state i
     |      
     |      @param i index of a state
     |      @param values tuple of mu, sigma
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij
     |  
     |  verboseStr(self)
     |  
     |  viterbi(self, emissionSequences)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      
     |      Result: [q_0, ..., q_T] the viterbi-path of emission_sequences is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class GaussianMixtureDistribution(ContinuousDistribution)
     |  Method resolution order:
     |      GaussianMixtureDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |      # XXX attributes unused at this point
     |  
     |  get(self)
     |  
     |  set(self, index, values)
     |      @param index index of mixture component
     |      @param values tuple of mu, sigma, w
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class GaussianMixtureHMM(GaussianEmissionHMM)
     |  HMMs with mixtures of Gaussians as emissions.
     |  
     |  Optional features:
     |  - fixing mixture components in training
     |  
     |  Method resolution order:
     |      GaussianMixtureHMM
     |      GaussianEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |  
     |  getEmission(self, i, comp)
     |      @returns (mu, sigma^2, weight) of component 'comp' in state 'i'
     |  
     |  getMixtureFix(self, state)
     |  
     |  setEmission(self, i, comp, values)
     |      Set the emission distribution parameters for a single component in a single state.
     |      
     |      @param i index of a state
     |      @param comp index of a mixture component
     |      @param values tuple of mu, sigma, weight
     |  
     |  setMixtureFix(self, state, flags)
     |  
     |  verboseStr(self)
     |      defines string representation
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from GaussianEmissionHMM:
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      Result: the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimate the model parameters given the training_sequences.
     |      
     |      Perform at most nr_steps until the improvement in likelihood
     |      is below likelihood_cutoff
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |      
     |      Result: Final loglikelihood
     |  
     |  baumWelchDelete(self)
     |      Delete the necessary temporary variables for Baum-Welch-reestimation
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps, loglikelihoodCutoff=0.0001)
     |      Setup necessary temporary variables for Baum-Welch-reestimation.
     |      
     |      Use with baumWelchStep for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |      Compute one iteration of Baum Welch estimation.
     |      
     |      Use with baumWelchSetup for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |  
     |  cfbGibbs(self, trainingSequences, bayes, width, delta, max_len, burnIn=100, seed=0)
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  forward(self, emissionSequence)
     |      Result: the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmissionProbability(self, value, i)
     |      @returns probability of emitting value in state i
     |  
     |  getTransition(self, i, j)
     |      @returns the probability of the transition from state i to state j.
     |      Raises IndexError if the transition is not allowed
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emissionSequences using the forward algorithm.
     |      
     |      @param emissionSequences SequenceSet
     |      
     |      Result: log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij
     |  
     |  viterbi(self, emissionSequences)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      
     |      Result: [q_0, ..., q_T] the viterbi-path of emission_sequences is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class HMM(__builtin__.object)
     |  The HMM base class.
     |  
     |  All functions where the C signatures allows it will be defined in here.
     |  Unfortunately there stil is a lot of overloading going on in derived classes.
     |  
     |  Generic features (these apply to all derived classes):
     |  - Forward algorithm
     |  - Viterbi algorithm
     |  - Baum-Welch training
     |  - HMM distance metric
     |  - ...
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  asMatrices(self)
     |      To be defined in derived classes.
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      @returns the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      # The functions for model training are defined in the derived classes.
     |  
     |  baumWelchDelete(self)
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps)
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  forward(self, emissionSequence)
     |      @returns the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmission(self, i)
     |      Accessor function for the emission distribution parameters of state 'i'.
     |      
     |      For discrete models the distribution over the symbols is returned,
     |      for continuous models a matrix of the form
     |      [ [mu_1, sigma_1, weight_1] ... [mu_M, sigma_M, weight_M]  ] is returned.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  getTransition(self, i, j)
     |      Accessor function for the transition a_ij
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emission_sequences using the forward algorithm
     |      
     |      @param emissionSequences is of type SequenceSet
     |      
     |      @returns log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setEmission(self, i, distributionParemters)
     |      Set the emission distribution parameters
     |      
     |      Defined in derived classes.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij.
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  viterbi(self, eseqs)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param eseqs can either be a SequenceSet or an EmissionSequence
     |      
     |      @returns [q_0, ..., q_T] the viterbi-path of \p eseqs is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class HMMFactory(__builtin__.object)
     |  A HMMFactory is the base class of HMM factories.
     |  A HMMFactory has just a constructor and a call method
     |  
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class HMMFromMatricesFactory(HMMFactory)
     |  @todo Document matrix formats
     |  
     |  Method resolution order:
     |      HMMFromMatricesFactory
     |      HMMFactory
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, emissionDomain, distribution, A, B, pi, hmmName=None, labelDomain=None, labelList=None, densities=None)
     |      # XXX TODO: this should use the editing context
     |  
     |  constructSwitchingTransitions(self, cmodel, pi, A)
     |      @internal function: creates switching transitions
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMMFactory:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class HMMOpenFactory(HMMFactory)
     |  Opens a HMM from a file.
     |  
     |  Currently four formats are supported:
     |  HMMer, our smo file format, and two xml formats.
     |  @note the support for smo files and the old xml format will phase out
     |  
     |  Method resolution order:
     |      HMMOpenFactory
     |      HMMFactory
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, fileName, modelIndex=None, filetype=None)
     |  
     |  __init__(self, defaultFileType=None)
     |  
     |  determineHMMClass(self, fileName)
     |  
     |  guessFileType(self, filename)
     |      guesses the file format from the filename
     |  
     |  openHMMER(self, fileName)
     |      Reads a file containing multiple HMMs in HMMER format, returns list of
     |      HMM objects or a single HMM object.
     |  
     |  openNewXML(self, fileName, modelIndex)
     |      Open one ore more HMM in the new xml format
     |  
     |  openOldXML(self, fileName)
     |      #obsolete
     |  
     |  openSMO(self, fileName, modelIndex)
     |      #obsolete
     |  
     |  openSingleHMMER(self, fileName)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMMFactory:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Hyperparameters
     |  Methods defined here:
     |  
     |  __init__(self, distribution, dimension)
     |  
     |  sampleParameters(self)
     |  
     |  setParameters(self, **kwargs)
    
    class InvalidModelParameters(GHMMError)
     |  Method resolution order:
     |      InvalidModelParameters
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class LabelDomain(Alphabet)
     |  # To be used for labelled HMMs. We could use an Alphabet directly but this way it is more explicit.
     |  
     |  Method resolution order:
     |      LabelDomain
     |      Alphabet
     |      EmissionDomain
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, listOfLabels)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Alphabet:
     |  
     |  __eq__(self, alph)
     |  
     |  __hash__(self)
     |  
     |  __len__(self)
     |  
     |  __str__(self)
     |  
     |  external(self, internal)
     |      Given an internal representation return the external representation
     |      
     |      @note the internal code -1 always represents a gap character '-'
     |      
     |      Raises KeyError
     |  
     |  externalSequence(self, internalSequence)
     |      Given a sequence with the internal representation return the external
     |      representation
     |      
     |      Raises KeyError
     |  
     |  getExternalCharacterLength(self)
     |      If all external characters are of the same length the length is
     |      returned. Otherwise None.
     |      @return length of the external characters or None
     |  
     |  internal(self, emission)
     |      Given a emission return the internal representation
     |  
     |  internalSequence(self, emissionSequence)
     |      Given a emission_sequence return the internal representation
     |      
     |      Raises KeyError
     |  
     |  isAdmissable(self, emission)
     |      Check whether emission is admissable (contained in) the domain
     |  
     |  size(self)
     |      @deprecated use len() instead
     |  
     |  toCstruct(self)
     |  
     |  verboseStr(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EmissionDomain:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class MultivariateGaussianDistribution(ContinuousDistribution)
     |  Method resolution order:
     |      MultivariateGaussianDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class MultivariateGaussianMixtureHMM(GaussianEmissionHMM)
     |  HMMs with Multivariate Gaussian distribution as emissions.
     |  
     |  States can have multiple mixture components.
     |  
     |  Method resolution order:
     |      MultivariateGaussianMixtureHMM
     |      GaussianEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomain, distribution, cmodel)
     |  
     |  __str__(self)
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |  
     |  getEmission(self, i, m)
     |      @returns mean and covariance matrix of component m in state i
     |  
     |  setEmission(self, i, m, values)
     |      Set the emission distributionParameters for mixture component m in
     |      state i
     |      
     |      @param i index of a state
     |      @param m index of a mixture component
     |      @param values tuple of mu, sigma
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from GaussianEmissionHMM:
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      Result: the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimate the model parameters given the training_sequences.
     |      
     |      Perform at most nr_steps until the improvement in likelihood
     |      is below likelihood_cutoff
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |      
     |      Result: Final loglikelihood
     |  
     |  baumWelchDelete(self)
     |      Delete the necessary temporary variables for Baum-Welch-reestimation
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps, loglikelihoodCutoff=0.0001)
     |      Setup necessary temporary variables for Baum-Welch-reestimation.
     |      
     |      Use with baumWelchStep for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |      
     |      @param trainingSequences can either be a SequenceSet or a Sequence
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |      Compute one iteration of Baum Welch estimation.
     |      
     |      Use with baumWelchSetup for more control over the training, computing
     |      diagnostics or doing noise-insertion
     |  
     |  cfbGibbs(self, trainingSequences, bayes, width, delta, max_len, burnIn=100, seed=0)
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  forward(self, emissionSequence)
     |      Result: the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmissionProbability(self, value, i)
     |      @returns probability of emitting value in state i
     |  
     |  getTransition(self, i, j)
     |      @returns the probability of the transition from state i to state j.
     |      Raises IndexError if the transition is not allowed
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emissionSequences using the forward algorithm.
     |      
     |      @param emissionSequences SequenceSet
     |      
     |      Result: log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij
     |  
     |  verboseStr(self)
     |  
     |  viterbi(self, emissionSequences)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      
     |      Result: [q_0, ..., q_T] the viterbi-path of emission_sequences is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class NoValidCDataType(GHMMError)
     |  Method resolution order:
     |      NoValidCDataType
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class PairHMM(HMM)
     |  Pair HMMs with discrete emissions over multiple alphabets.
     |  Optional features: continuous values for transition classes
     |  
     |  Method resolution order:
     |      PairHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomains, distribution, cmodel)
     |      create a new PairHMM object (this should only be done using the
     |      factory: e.g model = PairHMMOpenXML(modelfile) )
     |      @param emissionDomains list of EmissionDomain objects
     |      @param distribution (not used) inherited from HMM
     |      @param cmodel a swig pointer on the underlying C structure
     |  
     |  __str__(self)
     |      string representation (more for debuging) shows the contents of the C
     |      structure ghmm_dpmodel
     |      @return string representation
     |  
     |  addEmissionDomains(self, emissionDomains)
     |      add additional EmissionDomains that are not specified in the XML file.
     |      This is used to add information for the transition classes.
     |      @param emissionDomains a list of EmissionDomain objects
     |  
     |  checkEmissions(self, eps=1e-13)
     |      checks the sum of emission probabilities in all states
     |      @param eps precision (if the sum is > 1 - eps it passes)
     |      @return 1 if the emission of all states sum to one, 0 otherwise
     |  
     |  checkTransitions(self, eps=1e-13)
     |      checks the sum of outgoing transition probabilities for all states
     |      @param eps precision (if the sum is > 1 - eps it passes)
     |      @return 1 if the transitions of all states sum to one, 0 otherwise
     |  
     |  logP(self, complexEmissionSequenceX, complexEmissionSequenceY, path)
     |      compute the log probability of two sequences X and Y and a path
     |      @param complexEmissionSequenceX sequence X encoded as
     |      ComplexEmissionSequence
     |      @param complexEmissionSequenceY sequence Y encoded as
     |      ComplexEmissionSequence
     |      @param path the state path
     |      @return log probability
     |  
     |  verboseStr(self)
     |      string representation (more for debuging) shows the contents of the C
     |      structure ghmm_dpmodel
     |      @return string representation
     |  
     |  viterbi(self, complexEmissionSequenceX, complexEmissionSequenceY)
     |      run the naive implementation of the Viterbi algorithm and
     |      return the viterbi path and the log probability of the path
     |      @param complexEmissionSequenceX sequence X encoded as ComplexEmissionSequence
     |      @param complexEmissionSequenceY sequence Y encoded as ComplexEmissionSequence
     |      @return (path, log_p)
     |  
     |  viterbiPropagate(self, complexEmissionSequenceX, complexEmissionSequenceY, startX=None, startY=None, stopX=None, stopY=None, startState=None, startLogp=None, stopState=None, stopLogp=None)
     |      run the linear space implementation of the Viterbi algorithm and
     |      return the viterbi path and the log probability of the path
     |      @param complexEmissionSequenceX sequence X encoded as ComplexEmissionSequence
     |      @param complexEmissionSequenceY sequence Y encoded as ComplexEmissionSequence
     |      Optional parameters to run the algorithm only on a segment:
     |      @param startX start index in X
     |      @param startY start index in Y
     |      @param stopX stop index in X
     |      @param stopY stop index in Y
     |      @param startState start the path in this state
     |      @param stopState path ends in this state
     |      @param startLogp initialize the start state with this log probability
     |      @param stopLogp if known this is the logp of the partial path
     |      @return (path, log_p)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  asMatrices(self)
     |      To be defined in derived classes.
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      @returns the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      # The functions for model training are defined in the derived classes.
     |  
     |  baumWelchDelete(self)
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps)
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  forward(self, emissionSequence)
     |      @returns the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getEmission(self, i)
     |      Accessor function for the emission distribution parameters of state 'i'.
     |      
     |      For discrete models the distribution over the symbols is returned,
     |      for continuous models a matrix of the form
     |      [ [mu_1, sigma_1, weight_1] ... [mu_M, sigma_M, weight_M]  ] is returned.
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  getTransition(self, i, j)
     |      Accessor function for the transition a_ij
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emission_sequences using the forward algorithm
     |      
     |      @param emissionSequences is of type SequenceSet
     |      
     |      @returns log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  sample(self, seqNr, T, seed=0)
     |      Sample emission sequences.
     |      
     |      @param seqNr number of sequences to be sampled
     |      @param T maximal length of each sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a SequenceSet object.
     |  
     |  sampleSingle(self, T, seed=0)
     |      Sample a single emission sequence of length at most T.
     |      
     |      @param T maximal length of the sequence
     |      @param seed initialization value for rng, default 0 leaves the state
     |      of the rng alone
     |      @returns a EmissionSequence object.
     |  
     |  setEmission(self, i, distributionParemters)
     |      Set the emission distribution parameters
     |      
     |      Defined in derived classes.
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij.
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class PairHMMOpenFactory(HMMOpenFactory)
     |  factory to create PairHMM objects from XML files
     |  
     |  Method resolution order:
     |      PairHMMOpenFactory
     |      HMMOpenFactory
     |      HMMFactory
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, fileName_file_or_dom, modelIndex=None)
     |      a call to the factory loads a model from a file specified by the
     |      filename or from a file object or from a XML Document object and
     |      initializes the model on the C side (libghmm).
     |      @param fileName_file_or_dom load the model from a file specified by
     |      a filename, a file object or a XML Document object
     |      @param modelIndex not used (inherited from HMMOpenFactory)
     |      @return PairHMM object
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMMOpenFactory:
     |  
     |  __init__(self, defaultFileType=None)
     |  
     |  determineHMMClass(self, fileName)
     |  
     |  guessFileType(self, filename)
     |      guesses the file format from the filename
     |  
     |  openHMMER(self, fileName)
     |      Reads a file containing multiple HMMs in HMMER format, returns list of
     |      HMM objects or a single HMM object.
     |  
     |  openNewXML(self, fileName, modelIndex)
     |      Open one ore more HMM in the new xml format
     |  
     |  openOldXML(self, fileName)
     |      #obsolete
     |  
     |  openSMO(self, fileName, modelIndex)
     |      #obsolete
     |  
     |  openSingleHMMER(self, fileName)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMMFactory:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ParseFileError(GHMMError)
     |  Method resolution order:
     |      ParseFileError
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class SequenceCannotBeBuild(GHMMError)
     |  Method resolution order:
     |      SequenceCannotBeBuild
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class SequenceSet(__builtin__.object)
     |  A SequenceSet contains the *internal* representation of a number of
     |  sequences of emissions.
     |  
     |  It also contains a reference to the domain where the emissions orginated from.
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |      Deallocation of C sequence struct.
     |  
     |  __getitem__(self, index)
     |      @returns an EmissionSequence object initialized with a reference to
     |      sequence 'index'.
     |  
     |  __init__(self, emissionDomain, sequenceSetInput, labelDomain=None, labelInput=None)
     |      @p sequenceSetInput is a set of sequences from @p emissionDomain.
     |      
     |      There are several valid types for @p sequenceSetInput:
     |      - if @p sequenceSetInput is a string, it is interpreted as the filename
     |        of a sequence file to be read. File format should be fasta.
     |      - if @p sequenceSetInput is a list, it is considered as a list of lists
     |        containing the input sequences
     |      - @p sequenceSetInput can also be a pointer to a C sequence struct but
     |        this is only meant for internal use
     |  
     |  __len__(self)
     |      @returns the number of sequences in the SequenceSet.
     |  
     |  __str__(self)
     |      Defines string representation.
     |  
     |  asSequenceSet(self)
     |      convenience function, returns only self
     |  
     |  getGeneratingStates(self)
     |      @returns the state paths from which the sequences were generated as a
     |      Python list of lists.
     |  
     |  getSeqLabel(self, index)
     |  
     |  getSequence(self, index)
     |      @returns the index-th sequence in internal representation
     |  
     |  getStateLabel(self, index)
     |      @returns the labeling of the index-th sequence in internal representation
     |  
     |  getSubset(self, seqIndixes)
     |      @returns a SequenceSet containing (references to) the sequences with the
     |      indices in 'seqIndixes'.
     |  
     |  getWeight(self, i)
     |      @returns the weight of sequence i. @note Weights are used in Baum-Welch
     |  
     |  hasStateLabels(self)
     |      @returns whether the sequence is labeled or not
     |  
     |  merge(self, emissionSequences)
     |      Merges 'emissionSequences' into 'self'.
     |      @param emissionSequences can either be an EmissionSequence or SequenceSet
     |      object.
     |  
     |  sequenceLength(self, i)
     |      @returns the lenght of sequence 'i' in the SequenceSet
     |  
     |  setSeqLabel(self, index, value)
     |  
     |  setWeight(self, i, w)
     |      Set the weight of sequence i. @note Weights are used in Baum-Welch
     |  
     |  verboseStr(self)
     |      Defines string representation.
     |  
     |  write(self, fileName)
     |      Writes (appends) the SequenceSet into file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class SequenceSetSubset(SequenceSet)
     |  SequenceSetSubset contains a subset of the sequences from a SequenceSet
     |  object.
     |  
     |  @note On the C side only the references are used.
     |  
     |  Method resolution order:
     |      SequenceSetSubset
     |      SequenceSet
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __del__(self)
     |      Since we do not want to deallocate the sequence memory,
     |      the destructor has to be overloaded.
     |  
     |  __init__(self, emissionDomain, sequenceSetInput, ParentSequenceSet, labelDomain=None, labelInput=None)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from SequenceSet:
     |  
     |  __getitem__(self, index)
     |      @returns an EmissionSequence object initialized with a reference to
     |      sequence 'index'.
     |  
     |  __len__(self)
     |      @returns the number of sequences in the SequenceSet.
     |  
     |  __str__(self)
     |      Defines string representation.
     |  
     |  asSequenceSet(self)
     |      convenience function, returns only self
     |  
     |  getGeneratingStates(self)
     |      @returns the state paths from which the sequences were generated as a
     |      Python list of lists.
     |  
     |  getSeqLabel(self, index)
     |  
     |  getSequence(self, index)
     |      @returns the index-th sequence in internal representation
     |  
     |  getStateLabel(self, index)
     |      @returns the labeling of the index-th sequence in internal representation
     |  
     |  getSubset(self, seqIndixes)
     |      @returns a SequenceSet containing (references to) the sequences with the
     |      indices in 'seqIndixes'.
     |  
     |  getWeight(self, i)
     |      @returns the weight of sequence i. @note Weights are used in Baum-Welch
     |  
     |  hasStateLabels(self)
     |      @returns whether the sequence is labeled or not
     |  
     |  merge(self, emissionSequences)
     |      Merges 'emissionSequences' into 'self'.
     |      @param emissionSequences can either be an EmissionSequence or SequenceSet
     |      object.
     |  
     |  sequenceLength(self, i)
     |      @returns the lenght of sequence 'i' in the SequenceSet
     |  
     |  setSeqLabel(self, index, value)
     |  
     |  setWeight(self, i, w)
     |      Set the weight of sequence i. @note Weights are used in Baum-Welch
     |  
     |  verboseStr(self)
     |      Defines string representation.
     |  
     |  write(self, fileName)
     |      Writes (appends) the SequenceSet into file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SequenceSet:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class StateLabelHMM(DiscreteEmissionHMM)
     |  Labelled HMMs with discrete emissions.
     |  
     |  Same feature list as in DiscreteEmissionHMM models.
     |  
     |  Method resolution order:
     |      StateLabelHMM
     |      DiscreteEmissionHMM
     |      HMM
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, emissionDomain, distribution, labelDomain, cmodel)
     |  
     |  __str__(self)
     |  
     |  externalLabel(self, internal)
     |      @returns label representation of an int or list of ints
     |  
     |  getLabel(self, stateIndex)
     |      @returns label of the state 'stateIndex'.
     |  
     |  getLabels(self)
     |  
     |  gradientSearch(self, emissionSequences, eta=0.1, steps=20)
     |      trains a model with given sequences using a gradient descent algorithm
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      @param eta algortihm terminates if the descent is smaller than eta
     |      @param steps number of iterations
     |  
     |  internalLabel(self, external)
     |      @returns int representation of an label or list of labels
     |  
     |  kbest(self, emissionSequences, k=1)
     |      Compute the k probable labeling for each sequence in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or an
     |      EmissionSequence
     |      @param k the number of labelings to produce
     |      
     |      Result: [l_0, ..., l_T] the labeling of emissionSequences is an
     |      EmmissionSequence object,
     |      [[l_0^0, ..., l_T^0], ..., [l_0^j, ..., l_T^j]} for a j-sequence
     |      SequenceSet
     |  
     |  labeledBackward(self, emissionSequence, labelSequence, scalingVector)
     |      Result: the (N x T)-matrix containing the backward-variables
     |  
     |  labeledBaumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimates the model with the sequence in 'trainingSequences'.
     |      
     |      @note that training for models including silent states is not yet
     |      supported.
     |      
     |      @param trainingSequences EmissionSequence or SequenceSet object
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  labeledForward(self, emissionSequence, labelSequence)
     |      Result: the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  labeledViterbi(self, emissionSequences)
     |      @returns the labeling of the input sequence(s) as given by the viterbi
     |      path.
     |      
     |      For one EmissionSequence a list of labels is returned; for an SequenceSet
     |      a list of lists of labels.
     |  
     |  labeledlogikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s,l| model]) )_{s} of log-likelihoods of the
     |      individual \p emissionSequences using the forward algorithm
     |      
     |      @param emissionSequences SequenceSet
     |      
     |      Result: log( P[emissionSequences,labels| model]) of type float
     |      (numarray) vector of floats
     |  
     |  sample(self, seqNr, seqLength, seed=0)
     |  
     |  sampleSingle(self, seqLength, seed=0)
     |  
     |  setLabels(self, labelList)
     |      Set the state labels to the values given in labelList.
     |      
     |      LabelList is in external representation.
     |  
     |  verboseStr(self)
     |  
     |  write(self, fileName)
     |      Writes HMM to file 'fileName'.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from DiscreteEmissionHMM:
     |  
     |  applyBackgrounds(self, backgroundWeight)
     |      Apply the background distribution to the emission probabilities of states
     |      which have been assigned one (usually in the editor and coded in the XML).
     |      
     |      applyBackground computes a convex combination of the emission probability
     |      and the background
     |      
     |      @param backgroundWeight (within [0,1]) controls the background's
     |      contribution for each state.
     |  
     |  asMatrices(self)
     |      Return the parameters in matrix form.
     |  
     |  backwardTermination(self, emissionSequence, pybeta, scalingVector)
     |      Result: the backward log probability of emissionSequence
     |  
     |  baumWelch(self, trainingSequences, nrSteps=500, loglikelihoodCutoff=0.0001)
     |      Reestimates the model with the sequence in 'trainingSequences'.
     |      
     |      @note that training for models including silent states is not yet
     |      supported.
     |      
     |      @param trainingSequences EmissionSequence or SequenceSet object
     |      @param nrSteps the maximal number of BW-steps
     |      @param loglikelihoodCutoff the least relative improvement in likelihood
     |      with respect to the last iteration required to continue.
     |  
     |  cfbGibbs(self, trainingSequences, bayes, R=-1, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence or SequenceSet
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param R length of uniform compression >0, works best for .5log(sqrt(T)) where T is length of seq
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  extendDurations(self, durationlist)
     |      extend states with durations larger than one.
     |      
     |      @note this done by explicit state copying in C
     |  
     |  fbGibbs(self, trainingSequences, bayes, burnIn=100, seed=0)
     |      Reestimates the model and returns a sampled state sequence
     |      
     |      @note uses gsl, silent states not supported
     |      
     |      @param seed int for random seed, 0 default 
     |      @param trainingSequences EmissionSequence
     |      @param pA prior count for transitions
     |      @param pB prior count for emissions
     |      @param pPI prior count for initial state
     |      @param burnin number of iterations
     |      @return set of sampled paths for each training sequence
     |      @warning work in progress
     |  
     |  getBackgroundAssignments(self)
     |      Get the background assignments of all states
     |      
     |      '-1' -> no background
     |  
     |  getEmission(self, i)
     |  
     |  getSilentFlag(self, state)
     |  
     |  getTieGroups(self)
     |      Gets tied emission group structure.
     |  
     |  isSilent(self, state)
     |      @returns True if 'state' is silent, False otherwise
     |  
     |  removeTieGroups(self)
     |      Removes all tied emission information.
     |  
     |  setBackgroundAssignments(self, stateBackground)
     |      Change all the assignments of background distributions to states.
     |      
     |      Input is a list of background ids or '-1' for no background, or list of background names
     |  
     |  setBackgrounds(self, backgroundObject, stateBackground)
     |      Configure model to use the background distributions in 'backgroundObject'.
     |      
     |      @param backgroundObject BackgroundDistribution
     |      @param 'stateBackground' a list of indixes (one for each state) refering
     |      to distributions in 'backgroundObject'.
     |      
     |      @note values in backgroundObject are deep copied into the model
     |  
     |  setEmission(self, i, distributionParameters)
     |      Set the emission distribution parameters for a discrete model.
     |  
     |  setTieGroups(self, tieList)
     |      Sets the tied emission groups
     |      
     |      @param tieList contains for every state either '-1' or the index
     |      of the tied emission group leader.
     |      
     |      @note The tied emission group leader is tied to itself
     |  
     |  updateTiedEmissions(self)
     |      Averages emission probabilities of tied states.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from HMM:
     |  
     |  __del__(self)
     |      Deallocation routine for the underlying C data structures.
     |  
     |  backward(self, emissionSequence, scalingVector)
     |      @returns the (N x T)-matrix containing the backward-variables
     |  
     |  baumWelchDelete(self)
     |  
     |  baumWelchSetup(self, trainingSequences, nrSteps)
     |  
     |  baumWelchStep(self, nrSteps, loglikelihoodCutoff)
     |  
     |  clearFlags(self, flags)
     |      Clears one or more model type flags.
     |      @attention Use with care.
     |  
     |  distance(self, model, seqLength)
     |      @returns the distance between 'self.cmodel' and 'model'.
     |  
     |  forward(self, emissionSequence)
     |      @returns the (N x T)-matrix containing the forward-variables
     |      and the scaling vector
     |  
     |  getInitial(self, i)
     |      Accessor function for the initial probability $\pi_i$
     |  
     |  getStateFix(self, state)
     |  
     |  getStateName(self, index)
     |      returns the name of the state index
     |  
     |  getTransition(self, i, j)
     |      Accessor function for the transition a_ij
     |  
     |  hasFlags(self, flags)
     |      Checks if the model has one or more model type flags set
     |  
     |  joined(self, emissionSequence, stateSequence)
     |      log P[ emissionSequence, stateSequence| m]
     |  
     |  loglikelihood(self, emissionSequences)
     |      Compute log( P[emissionSequences| model]) using the forward algorithm
     |      assuming independence of the sequences in emissionSequences
     |      
     |      @param emissionSequences can either be a SequenceSet or a EmissionSequence
     |      
     |      @returns log( P[emissionSequences| model]) of type float which is
     |      computed as $\sum_{s} log( P[s| model])$ when emissionSequences
     |      is a SequenceSet
     |      
     |      @note The implementation does not compute the full forward matrix since
     |      we are only interested in the likelihoods in this case.
     |  
     |  loglikelihoods(self, emissionSequences)
     |      Compute a vector ( log( P[s| model]) )_{s} of log-likelihoods of the
     |      individual emission_sequences using the forward algorithm
     |      
     |      @param emissionSequences is of type SequenceSet
     |      
     |      @returns log( P[emissionSequences| model]) of type float
     |      (numarray) vector of floats
     |  
     |  normalize(self)
     |      Normalize transition probs, emission probs (if applicable)
     |  
     |  pathPosterior(self, sequence, path)
     |      @returns the log posterior probability for 'path' having generated
     |      'sequence'.
     |      
     |      @attention pathPosterior needs to calculate the complete forward and
     |      backward matrices. If you are interested in multiple paths it would
     |      be more efficient to use the 'posterior' function directly and not
     |      multiple calls to pathPosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  posterior(self, sequence)
     |      Posterior distribution matrix for 'sequence'.
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  printtypes(self, model_type)
     |  
     |  randomize(self, noiseLevel)
     |      to be defined in derived class
     |  
     |  setFlags(self, flags)
     |      Sets one or more model type flags.
     |      @attention Use with care.
     |  
     |  setInitial(self, i, prob, fixProb=False)
     |      Accessor function for the initial probability $\pi_i$.
     |      
     |      If 'fixProb' = True $\pi$ will be rescaled to 1 with 'pi[i]'
     |      fixed to the arguement value of 'prob'.
     |  
     |  setStateFix(self, state, flag)
     |  
     |  setStateName(self, index, name)
     |      sets the state name of state index to name
     |  
     |  setTransition(self, i, j, prob)
     |      Accessor function for the transition a_ij.
     |  
     |  state(self, stateLabel)
     |      Given a stateLabel return the integer index to the state
     |  
     |  statePosterior(self, sequence, state, time)
     |      @returns the log posterior probability for being at 'state'
     |      at time 'time' in 'sequence'.
     |      
     |      @attention: statePosterior needs to calculate the complete forward
     |      and backward matrices. If you are interested in multiple states
     |      it would be more efficient to use the posterior function directly
     |      and not multiple calls to statePosterior
     |      
     |      @todo for silent states things are more complicated -> to be done
     |  
     |  updateName2id(self)
     |      adds all state names to the dictionary name2id
     |  
     |  viterbi(self, eseqs)
     |      Compute the Viterbi-path for each sequence in emissionSequences
     |      
     |      @param eseqs can either be a SequenceSet or an EmissionSequence
     |      
     |      @returns [q_0, ..., q_T] the viterbi-path of \p eseqs is an
     |      EmmissionSequence object,
     |      [[q_0^0, ..., q_T^0], ..., [q_0^k, ..., q_T^k]} for a k-sequence
     |      SequenceSet
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from HMM:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class TruncGaussianDistribution(GaussianDistribution)
     |  Method resolution order:
     |      TruncGaussianDistribution
     |      GaussianDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |      # XXX attributes unused at this point
     |  
     |  get(self)
     |  
     |  set(self, values)
     |      @param values tuple of mu, sigma, trunc
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class UniformDistribution(ContinuousDistribution)
     |  Method resolution order:
     |      UniformDistribution
     |      ContinuousDistribution
     |      Distribution
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, domain)
     |  
     |  get(self)
     |  
     |  set(self, values)
     |      @param values tuple of maximum, minimum
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Distribution:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class UnknownInputType(GHMMError)
     |  Method resolution order:
     |      UnknownInputType
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class UnsupportedFeature(GHMMError)
     |  Method resolution order:
     |      UnsupportedFeature
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class WrongFileType(GHMMError)
     |  Method resolution order:
     |      WrongFileType
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class badCPointer(GHMMError)
     |  Method resolution order:
     |      badCPointer
     |      GHMMError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from GHMMError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message

FUNCTIONS
    HMMDiscriminativePerformance(HMMList, SeqList)
        Computes the discriminative performce of the HMMs in HMMList
        under the sequences in SeqList
    
    HMMDiscriminativeTraining(HMMList, SeqList, nrSteps=50, gradient=0)
        Trains a couple of HMMs to increase the probablistic distance
        if the the HMMs are used as classifier.
        
        @param HMMList List of labeled HMMs
        @param SeqList List of labeled sequences, one for each HMM
        @param nrSteps maximal number of iterations
        @param gradient @todo document me
        
        @note this method does a initial expectation maximization training
    
    HMMwriteList(fileName, hmmList, fileType='xml')
    
    IntegerRange(a, b)
        Creates an Alphabet with internal and external representation of range(a,b)
        @return Alphabet
    
    SequenceSetOpen(emissionDomain, fileName)
        Reads a sequence file with multiple sequence sets.
        
        @returns a list of SequenceSet objects.
    
    logwrapper(level, message)
    
    writeToFasta(seqSet, fn)
        Writes a SequenceSet into a fasta file.

DATA
    AminoAcids = <ghmm.Alphabet object>
    DNA = <ghmm.Alphabet object>
    GHMM_FILETYPE_HMMER = 'hmm'
    GHMM_FILETYPE_SMO = 'smo'
    GHMM_FILETYPE_XML = 'xml'
    HMMFromMatrices = <ghmm.HMMFromMatricesFactory object>
    HMMOpen = <ghmm.HMMOpenFactory object>
    HMMOpenHMMER = <ghmm.HMMOpenFactory object>
    HMMOpenSMO = <ghmm.HMMOpenFactory object>
    HMMOpenXML = <ghmm.HMMOpenFactory object>
    PairHMMOpenXML = <ghmm.PairHMMOpenFactory object>
    c_log = [<bound method Logger.critical of <logging.Logger object>>, <b...
    fmt = <logging.Formatter object>
    hdlr = <logging.StreamHandler object>
    kBackgroundDistributions = 32
    kContinuousHMM = 512
    kDiscreteHMM = 256
    kHigherOrderEmissions = 16
    kLabeledStates = 64
    kLeftRight = 1
    kNotSpecified = 0
    kPairHMM = 1024
    kSilentStates = 4
    kTiedEmissions = 8
    kTransitionClasses = 128
    log = <logging.Logger object>
    types = {1: 'kLeftRight', 4: 'kSilentStates', 8: 'kTiedEmissions', 16:...


